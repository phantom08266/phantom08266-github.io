---
title: RealMySql 8.0 - 아키텍처(InnoDB 스토리지 엔진)
date: 2023-08-11
categories: [도서, RealMySql]
tags: [mysql, RealMySql, 아키텍처, InnoDB, 스토리지]
math: true
mermaid: true
---


## InnoDB 스토리지 엔진의 특징
Mysql 스토리지 엔진 중에서 가장 많이 사용하는 엔진이다. <br>
가장 많이 사용하는 이유는 
- 레코드 기반 잠금을 지원
- 높은 동시성 처리
- 높은 안정성과 성능이 뛰어남

<br>

### 1. 프라이머리키에 의한 클러스터링
InnoDB 스토리지 엔진의 모든 테이블은 PK를 클러스터링되어 저장한다. <br>
세컨더리 인댁스인 경우 레코드 주소대신 PK를 사용하여 논리적인 주소로 사용한다. <br>
PK가 다른 인덱스보다 실행계획에서 높게 잡힌다. <br>

> MyISAM 스토리지 엔지은 클러스터링 개념이 없으므로 PK, 세컨더리 인덱스 구조가 아무런 차이가 없다. <br> 
> 단지 PK는 유니크 특성만 추가된 개념으로만 인식한다.

<br>

### 2. 외래키 지원
InnoDB 스토리지 엔진 차원에서 지원하는 기능이다. <br>
외래키는 특성 상 테이블간의 확장 및 변경의 용이성을 떨어트리기 때문에 적용 시 신중하게 고려해야 한다. <br>

```shell
mysql> SET foreign_key_checks = OFF;
mysql> SET foreign_key_checks = ON;
```

위 명령어를 통해서 외래키 체크를 온 오프 할 수 있다. <br>
물론 편리하게 사용하기 위한 것임으로 반드시 다시 ON할 경우 외래키에 문제가 없도록 해야한다. <br>

> 설정을 Global, Session 단위로 설정할 수 있으며, 보통 세션단위로 설정을 한다. <br>
> 따라서 SET SESSION foreign_key_checks = ON; 로 설정이 가능하지만 기본적으로 SESSION 명령어를 사용하지 않아도 세션단위로 동작한다. 

<br>

### 3. MVCC (Multi Version Concurrency Control)
레코드 레벨의 트랜잭션을 지원하는 DBMS들은 모두 지원한다. <br>
**MVCC의 목적은 잠금을 사용하지 않고 일관된 읽기 작업을 제공**한다. <br>
일관된 읽기 작업은 **언두 로그**(Undo log) 기능으로 구현된다. <br>

1. Insert되면 InnoDB 버퍼 풀, 디스크에 저장된다. <br>
2. Insert한 데이터를 Update하게되면 이때부터 언두 로그에 적재되고 버퍼 풀에는 바로 업데이트 된다.(언두로그에 적재되는 데이터는 변경 전 데이터가 저장된다.)
3. 디스크에 저장되는 시점은 Commit이 되거나 Write스레드가 동작할때 반영되지만 ACID 특성을 보장하기 때문에 걱정하지 않아도 된다. 
4. 이제부터는 Transction Isolation Level에 따라서 언두로그에 있는 정보를 읽을지, 버퍼 풀에 있는 데이터를 읽을 지 결정한다.

> Read_Uncommitted인 경우에는 버퍼 풀에 있는 데이터를 읽어오고 <br>
> Read_committed 이상인 경우에는 언두로그에 있는 데이터를 읽거나 버퍼 풀에 있는 데이터를 읽어온다. <br>

언두로그는 백업을 하거나 트랜잭션이 종료되어야지 데이터가 삭제된다. <br>
따라서 Commit이 되었다고 반드시 언두로그에 저장했던 데이터가 삭제되는 것이 아니다. <br>
그 이유는 Commit이 되어도 Rollback이 필요할 수 있기 때문이다. <br>

<br>

### 4. 잠금 없는 일관된 읽기(Non-Locking Consistent Read)
MVCC를 통해서 잠금 없는 일관된 읽기를 지원한다. <br>

단 격리 수준이 SERIALIZABLE인 경우를 제외하고 나머지 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ는 잠금 없는 일관된 읽기를 지원한다. <br>
이와 같은 기능이 가능한 이유는 앞서 설명한 언두로그 덕분이다. <br>

따라서 언두로그가 중요한데 문제없이 잘 사용하려면 언두로그의 용량이 넉넉해야 한다. <br>
즉 오랜 시간동안 활성화된 트랜잭션을 제거하거나 롤백을 통해서 언두로그를 정리해야 Mysql 서버가 느려지는 등의 문제를 벗어날 수 있다. <br>

<br>

### 5. 자동 데드락 감지

InnoDB 스토리지 엔진은 트랜잭션 중에서 교착상태에 빠진 트랜잭션들을 찾는 **데드락 감지 스레드**가 있어 강제로 종료시킨다. <br>
만약 교착상태에 빠진 트랜잭션이 여러개인 경우에는 언두 로그가 가장 작은 순 부터 트랜잭션을 종료시킨다. <br>
이유는 언두로그가 적다는 말은 처리해야할 내용이 적다는 것이기 때문에 부하가 덜 발생할 것이기 때문이다. <br>

> 기본적으로 InnoDB 스토리지 엔진은 상위 레이어인 Mysql 엔진에서 관리하는 테이블 잠금을 확인할 수 없다. <br>
> 하지만 innodb_table_locks 시스템 변수를 활성화하면 확인할 수 있다.

데드락 감지 스레드는 검사를 할때 잠금상태가 변경되지 않도록 또다른 Lock을 걸고 작업을 하게되는데 이로인해 서비스 성능에 악영향을 줄 수도 있다. <br>
따라서 스레드로 인한 CPU 자원이 소모되기 때문에 아예 스레드를 생성하지 않도록 **innodb_deadlock_detect** 시스템 변수를 **OFF**로 설정할 수 있다. <br>

물론 이렇게 하면 교착상태에 빠진 트랜잭션이 종료가 안되는 현상이 발생함으로 **innodb_lock_wait_timeout** 시스템 변수를 사용하여 일정시간이 지나면 종료되도록 설정할 수 있다. <br>

<br>

### 6. 자동화된 장애 복구

InnoDB 스토리지 엔진에는 장애 발생 시 자동으로 복구하는 매커니즘이 탑재되어 있다. 
따라서 서버가 실행될때 자동복구를 수행하고 복구가 불가능하면 서버를 종료시킨다. <br>

만약에 강제 종료가 된다면 innodb_force_recovery 시스템 변수를 사용하여 복구를 시도할 수 있다. <br>
1 ~ 6까지 숫자값을 이용하여 복구를 시도할 수 있다. <br>

- 1 : 데이터나 인덱스 페이지가 손상될때 사용하며 덤프해서 다시 구축하는 것이 좋다. 
- 2 : 메인스레드가 언두 데이터를 삭제하는데 이 과정에서 문제가 발생한 것임으로 이를 복구한다. 
- 3 : 커밋되지 않는 트랜잭션 작업을 롤백하지 않고 그대로 냅두도록 한다. (mysqldump를 사용하여 다시 구축하는 것이 좋다.)
- 4 : 인덱스에 관련된 부분이라 데이터 손실 없이 복구가 가능하다. 
- 5 : 커밋되지 않던 작업도 커밋된것처럼 처리되기 때문에 잘못된 데이터가 저장될 수 있음. (다시 구축하는 것이 좋다.)  
- 6 : 이 복구 모드로 시작하면 리두 로그를 모두 무시한 채로 서버가 실행된다. 

위 복구 모드를 순서대로 적용해도 해결이 안되면 풀 백업과 장애 시점까지의 바이너리 로그로 복구를 하는게 데이터 손실이 더 적을 수 있다. <br>

<br>

### 7. InnoDB 버퍼 풀
디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐싱하는 역할을 한다. <br>
즉 디스크 I/O를 줄여서 성능을 향상시킬 수 있다. <br>

**[버퍼 풀 크기 설정 방법]** <br>
Mysql5.7 버전부터 크기 설정이 가능해 졌으며, **innodb_buffer_pool_size** 시스템 변수를 사용하여 설정할 수 있다. <br>
동적으로 변경이 가능하지만 당연한 말일 수 있지만 한가한 시간대에 작업하는 것이 좋다. <br>
버퍼 풀은 내부적으로 128MB 청크 단위로 쪼개어 관리되기 때문에 128MB 단위로 증감 하는것이 좋다. <br>

**innodb_buffer_pool_instances** 시스템 변수를 이용하여 버퍼 풀을 여러개로 분리해서 관리할 수 있으며, 버퍼 풀이 40GB 이하라면 8로 유지하고 인스턴스당 5GB로 설정하는 것이 좋다. <br>

<br>

**[버퍼 풀 구조]** <br>
버퍼 풀은 페이지 조각 관리를 하기 위해 3개의 자료 구조를 관리한다. <br>
1. LRU(Least Recently Used) 리스트 : 페이지들이 언제 사용되었는지를 기록하는 자료구조이다.(오래된 것일수록 LRU, 잦은 호출일 수록 MRU) <br>
2. Flush 리스트 : 디스크에서 읽은 상태에서 변경된 내용들을 기록하는 자료구조이다. <br>
3. 프리 리스트 : 비어있는 페이지들의 리스트이다. <br>

<br>

**[버퍼 풀과 리두 로그]** <br>
버퍼 풀을 크게 설정할 수록 캐싱효과로 인해 쿼리 성능이 향상된다. <br>
하지만 버퍼 풀 사이즈만 크게 설정한다는건 캐싱효과만 높이는 것이지 쓰기 버퍼링 기능을 높이는 것은 아니다. <br>
데이터베이스의 성능을 높이려면 쓰기 버퍼링 기능도 향상시켜야 한다. <br>

버퍼 풀에는 2개의 페이지 단위로 저장되어있다. <br>
- 클린 페이지 : 디스크에서 읽어온 변경되지 않는 데이터
- 더티 페이지 : Insert, Update, Delete 작업으로 변경된 데이터

하지만 버퍼 풀에 무한정 더티 페이지들이 저장될 수 없으므로 보통 리두로그를 사용하여 순환 연결리스트 형식으로 관리한다. <br>
따라서 리두 로그 파일의 크기가 작을수록 더티 페이지를 버퍼 풀에 유지시키는 기간이 짧아진다는 말이며 이는 쓰기 성능이 떨어진다는 말이된다. <br>

따라서 버퍼 풀이 100GB이하 라면 리두 로그 파일의 크기는 5~10GB로 설정하는 것이 좋다. <br>
버퍼 풀에는 전체 데이터를 가지고 있지만 리두에는 변경된 것만 가지고 있기 때문에 상대적으로 적용 용량이 필요하기 때문에 필요할때마다 늘려주는 것이 좋다. <br>

<br>

**[버퍼 풀 플러시]** <br>
Mysql 8.0 부터는 버퍼 풀 플러시를 할때 쓰기 폭증 현상이 발생되지 않는다. <br>
그 이유는 플러시 리스트, LRU 리스트 덕분이다. <br>

앞서 말했듯이 **플러시 리스트**는 디스크에서 읽어온 상태에서 변경된 내용들을 기록하는 자료구조이다. <br>
따라서 더티 페이지를 디스크로 동기화 하는 클리너 스레드는 플러시 리스트의 내용을 디스크로 동기화 한다. <br>
보통 클리너 스레드와 버퍼 풀 인스턴스는 1:1 관계로 갯수를 동일하게 맞춰 설정한다. <br>

**innodb_max_dirty_page_pct_lwm**, **innodb_io_capacity** 등의 값들을 설정하여 더티 페이지의 양을 체크하고 주기적으로 디스크로 동기화를 진행하여 
디스크 쓰기 폭발을 방지한다. <br>

<br>

**LRU 리스트**는 사용이 낮은 페이지들을 정리하기 위해서 사용하는 자료구조이다. <br>
최대 **innodb_lru_scan_depth** 만큼 페이지들을 스캔하고, 디스크로 동기화한다음 프리리스트로 페이지를 옮긴다. <br>

> LRU 스캔은 (innodb_buffer_pool_instances * innodb_lru_scan_depth) 만큼의 페이지를 스캔한다.


<br>

**[버퍼 풀 상태 백업 및 복구]** <br>
Mysql 5.6 이전에는 서비스를 오픈하기 전에 **워밍업**이라 해서 버퍼 풀에 데이터를 미리 올려두는 작업을 해야했다. <br>
하지만 Mysql 5.6 부터는 **버퍼 풀 상태 백업 및 복구** 기능을 제공한다. <br>

```shell
# Mysql 셧다움 전에 버퍼 풀의 상태 백업
mysql> SET GLOBAL innodb_buffer_pool_dump_now=ON;
# Mysql 서버 재시작 후 백업된 버퍼 풀의 상태 복구
mysql> SET GLOBAL innodb_buffer_pool_load_now=ON;
```

<br>
버퍼 풀의 백업은 ib_buffer_pool이라는 파일로 생성되는데 이 파일의 실제 용량을 보면 상당히 적은 것을 확인할 수 있다. <br>
버퍼 풀은 읽어온 모든 데이터를 저장하여 클 것으로 판단하였는데 작은 이유는 메타데이터만 가지고 저장했기 때문이다. <br>
따라서 메타데이터를 토대로 다시 디스크에서 읽어와야하기 때문에 복구 시간이 오래걸릴 수 있다. <br>

<br>

**[버퍼 풀의 적재 내용 확인]** <br>
information_schema 데이터베이스에는 **innodb_buffer_page** 테이블을 이용해서 어떤 테이블의 페이지들이 적재되어 있는지를 확인할 수 있다. <br>
하지만 성능이슈가 있어 운영에서는 사용할 수 없었는데 8.0부터는 innodb_cached_indexes 테이블을 이용해서 확인할 수 있다. <br>

또한 테이블 전체 페이지 중에서 대략 어느정도 비율이 InnoDB 버퍼 풀에 적재되었는지도 확인할 수 있다. <br>





