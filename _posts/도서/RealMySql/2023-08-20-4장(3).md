---
title: RealMySql 8.0 - 아키텍처(MyISAM 스토리지 엔진)
date: 2023-08-20
categories: [도서, RealMySql]
tags: [mysql, RealMySql, 아키텍처, MyISAM, 스토리지]
math: true
mermaid: true
---

MyISAM 스토리지 엔진에는 InnoDB의 버퍼풀 등의 개념이 존재하지 않는다.
대신 버퍼 풀을 대신하는 키 캐시 라는 개념이 있다.

키 캐시의 히트율은 99% 이상으로 유지하는 것이 권장사항이며, 캐시 히트율이 적다면 캐시 메모리 공간을 늘려 더 많은 데이터를 캐싱 하도록 하는 것이 방법이 될 수 있다.

보통 32비트 운영체제는 4GB의 메모리 공간을 할당해주고 64비트 운영체제는 OS_PER_PROCESS_LIMIT 설정값만큼 할당할 수 있다.

### 운영체제의 캐시 및 버퍼
키 캐시를 사용하지 못하는 경우에는 MyISAM에는 별다른 캐싱할 버퍼 풀 등의 매커니즘을 가지고 있지 않는다.
그렇다고 키 캐시 히트가 되지 않는 모든 경우 디스크에서 데이터를 읽어오는 것은 아니고 DBMS도 결국 운영체제 위에서 동작하기 때문에 운영체제의 캐시 기능을 도움받을 수는 있다.
다만 운영체제의 캐시는 기본 원칙이 캐시 공간은 메모리 공간에서 남는 부분을 사용하기 때문에 캐시공간을 위해서 메모리를 충분히 비워두어야 한다. (따라서 MyISAM이 동작하는 서버에는 물리 메모리 공간이 최대 40%이상을 넘지 않도록 유지하는것이 좋다.)


### 데이터 파일과 프라이머리키(인덱스) 구조
MyISAM에서는 InnoDB처럼 클러스터링 개념이 없다.
따라서 레코드를 저장할때 ROWID라는 물리 주소값을 같이 저장하고 PK또는 세컨더리 인덱스가 ROWID값을 포인터로 가지도록 한다.
ROWID는 고정길이, 가변길이 2가지 방식이 있고 주로 가변길이를 사용한다고 한다.



## Mysql 로그 파일
Mysql 서버에 장애가 발생하면 기본적으로 로그를 확인하는 습관을 들이는 것이 좋다.
에러 로그는 my.cnf 파일에 설정한 log_error 이름의 파라미터로 정의된 경로에 생성되며, 별도의 설정을 하지 않는 경우 설치 경로의 data폴더에 생성된다. 파일 형식은 .err 라는 확장자로 생성된다.


### Mysql이 시작하는 과정과 관련된 정보성 및 에러 메시지
서버가 비정상 종료 후 재시작할 경우에는 반드시 로그를 확인해야 한다. 정상적으로 connection이 되었는지, ignore된 경우가 없는지 등을 확인해야한다.

### 비정상 종료 시 InnoDB 트랜잭션 복구 메시지
InnoDB의 경우 서버가 강제종료된 경우나 비정상 종료인 경우 완료하지 못한 트랜잭션 처리를 정리하고 디스크에 기록하는 작업을 하게된다.
이때 정상적으로 처리되면 간단한 로그를 작성하는데 만약 복구가 안될 경우 에러로그를 작성하고 다시 종료된다.
따라서 해당 로그를 파악하고 innodb_force_recovery파라미터를 0이상으로 설정하여 복구절차를 진행하면 실행되는 경우도 있다.


### 쿼리 처리 동중에 발생하는 에러 메시지
사전 예방은 어렵지만 주기적으로 로그를 확인하는 습관을 들이면 에러, 복제 등의 문제를 알 수 있다.


### 비정상적으로 종료된 커넥션 메시지
max_connect_errors 시스템 변수값이 너무 낮게 설정되어 있을 수 있다.
클라이언트에서 연결 실패한 횟수가 해당 시스템 변수를 넘게 되면 발생한다.


### InnoDB의 모니터링 또는 상태조회 명령
* SHOW ENGINE INNODB STATUS

모니터링을 활성화를 하면 확인 후 반드시 비활성화를 해야한다. 활성화 시 로그파일에 많은 정보가 저장되기 때문에 에러 로그파일이 모니터링 값으로 커지지 않도록 해야한다.

### Mysql 종료 메시지
Mysql서버가 갑자기 종료되거나 아무 이유없이 재시작되는 경우에는 반드시 로그를 확인해서 원인을 파악해야 한다.
만약 다른 사용자가 종료했다면 'Received SHUTDOWN from user ~ ' 메시지가 저장되어있거나 스택 트레이스 혹은 아무 메시지도 없는 경우에는 Mysql 문서에서 'The Error log' 절을 확인해야한다.

### 제너럴 쿼리 로그 파일
만약 서비스에서 실행되는 쿼리들을 알고 싶을 경우에는 쿼리로그를 활성화해서 로그파일로 기록하도록 한다.
제너럴 쿼리는 슬로우 쿼리랑 다르게 요청이 들어오면 쿼리 실행전에 로그를 작성하기 때문에 에러와 상관없이 저장된다고 보면된다.
쿼리 로그 파일의 경로는 general_log_file 설정값으로 설정되어 있다.

만약 로그를 파일로 저장한 것이 아니라 테이블로 저장했다면 아래 명령어를 통해서 확인 가능하다.(log_output설정값을 통해 설정 가능하다)
* SHOW GLOBAL VARIABLES LIKE 'general_log_file';

### 슬로우 쿼리 로그
정상적으로 실행된 쿼리 중 log_query_time 시스템 변수보다 큰 실행시간을 가진 쿼리를 저장한다.

Time : 쿼리 시작시간이 아니라 종료시간을 의미하며, 만약 시작시간을 알려면 Query_time을 빼야한다. <br>
Query_time: 쿼리가 실행되는 시간을 의미 <br>
Lock_time: Mysql엔진 레벨에서 관리하는 테이블 잠금에 대해서만 표현하며, 테이블 락을 거는 시간 + 코드 실행시간을 합한 시간이 표시되어 해당 값이 작으면 무시해도된다. <br>
Rows_examined : 쿼리가 처리되기 위해 몇 건의 레코드에 접근했는지 의미 <br>
Rows_sent : 실제 몇 건의 처리 결과를 클라이언트로 보냈는지 의미 <br>
따라서 Rows_examined가 큰데 Rows_sent값이 작다면 조금 더 적은 레코드를 조회하도록 튜닝해볼 수 있다는 의미이기도 하다. <br>

또한 InnoDB의 Lock_time의 값이 MVCC 매커니즘을 사용하는데도 1초 이상 소요될 수 있는데 이는 InnoDB레코드 수준이 아니라 Mysql엔진 레벨에서의 테이블 잠금으로 인해 발생할 가능성이 크다.

* 만약 슬로우쿼리, 제너럴 쿼리가 너무 많아서 검토하기 어려우면 percona Toolkit의 pt-query-digest 스크립트를 사용해보는 것도 좋다.

