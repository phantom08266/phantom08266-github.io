---
title: RealMySql 8.0 - InnoDB 스토리지 엔진 잠금
date: 2023-09-04
categories: [도서, RealMySql]
tags: [mysql, RealMySql, InnoDB, 스토리지, 락]
math: true
mermaid: true
---


InnoDB는 스토리지 엔진 단에서 레코드 기반의 락을 제공하기 때문에 MyISAM보다 뛰어난 동시성 처리를 지원한다. 
하지만 Mysql서버에서 제어하기 힘들기 때문에 이전에는 lock_monitor 테이블을 생성해서 락에 대한 정보를 저장하고 이를 통해 Mysql서버가 인지하거나 SHOW ENGINE INNODB STATUS 명령어를 통해 알아보는 것이 전부였다. 


최근에는 Information_schema 테이블들을 조인하여 어떤 트랜잭션이 어떤 잠금을 하고 있는지, 해당 잠금을 어느 트랜잭션이 가지고 있는지 확인할 수 있다. 시간도 알수 있어서 오래된 트랜잭션을 가지고 있는 클라이언트를 찾아 종료시킬 수 있다.
- InnoDB_TRX
- INNODB_LOCKS
- INNODB_LOCK_WAITS

> Performance Schema를 이용해서 InnoDB 스토리지 엔진의 내부 잠금에 대한 모니터링도 지원한다.



## InnoDB 스토리지 엔진 잠금

### 레코드 락
레코드 락은 기본적으로 레코드 자차체를 잠그는 것을 말한다. 하지만 InnoDB에서는 명확하게는 인덱스의 레코드를 잠그는 것이다.
레코드 자체를 잠그는지 인덱스를 잠그는것의 차이는 크기때문에 알고 있어야 한다.

또한 PK, 유니크 인덱스에 의한 변경 작업은 갭 락 이 걸리지 않고 레코드 자체에 대해서만 락을 적용한다.


### 갭 락
다른 DBMS에는 없지만 Mysql에만 있는 락이며, 레코드와 레코드 사이의 간격에 락을 거는 개념이다. 따라서 해당 간격에 새로운 레코드가 생성되는 것을 방지한다. 주로 넥스트 키 락의 일부로 사용된다.


### 넥스트 키 락
레코드 락 과 갭 락을 합쳐놓은 잠금 형태를 말한다.
주로 레플리카 서버에서 소스 서버의 결과물과 동일한 결과물을 만들어내도록 보장하기 위해 사용된다. 
하지만 넥스트키 락 과 갭 락 으로 인해 데드락이 발생하거나 다른 트랜잭션이 기다리는 현상이 종종 발생한다. 따라서 바이너리 로그 포맷을 ROW형태로 저장하는 것이 넥스트키 락, 갭 락을 줄이는 방안이 될 수 있다.
그래서 Mysql 8.0부터는 ROW형태가 기본값이다.


### 자동 증가 락
Mysql5.0 이하 버전에서는 테이블에 Insert, Replace쿼리 문장을 날리면 Auto_Increment 락이 걸리면서 Mysql 값을 순증으로 할당한다.
테이블에 단 하나만 존재하기 때문에 값을 넣을때 Auto_Increment락을 획득해야한다. 하지만 보통 아주 짧은 시간이기 때문에 이로인해 문제가 되지는 않는다.

Mysql5.1이상부터는 innodb_autoinc_lock_mode값을 통해서 자동 증가 락 작동방식을 변경 가능하다. 

Mysql 5.7까지는 innodb_autoinc_lock_mode가 1이었지만 8.0부터는 2로 변경되었다. 이유는 바이너리 로그 포맷이 ROW포맷이 되었기 때문이다. 
이는 만약 ROW 포멧이 아닌 STATEMENT포맷을 사용하는것으로 변경했다면 innodb_autoinc_lock_mode 도 1로 변경하는 것을 권장한다.


## 인덱스와 잠금
앞서 레코드 락을 설명하면서 인덱스의 레코드를 잠근다고 표현했었다. 
이에 대해 설명을 보완하자면, 인덱스에 해당한다면 여러 테이블이 잠금될 수 있다는 말이다.

Mysql은 인덱스를 이용하여 레코드를 찾아 일치하는 레코드에 락을 걸게된다. 즉 wherer절에 조건이 많이 있어도 인덱스가 걸린 칼럼들에 대해서만 찾기 때문에 first_name, last_name 두 컬럼 중 first_name에만 인덱스가 걸려있다면 중복되는 항목들 모두 락이 걸려버리게 된다.
즉 이로 인해 잘못 이해하고 사용한다면 동시성이 떨어지는 문제가 발생할 수 있다. (만약 인덱스가없다면 풀스캔을 한다는 말이고 이는 곳 해당 테이블에 있는 모든 레코드가 락이 걸린다는 말이다.)


## 레코드 수준의 잠금 확인 해제
실습을 하고 업데이트 할 것.



## Mysql 격리 수준
트랜잭션 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것이다. 

- Read Uncommitted
- Read Committed
- Repeatable Read
- Serializable

InnoDB에서는 Repeatable Read일때 Phantom Read가 발생하지 않는다.
일반적인 온라인 서비스용 도메인인 경우 Read Committed, Reapeatable Read 중 하나를 사용한다.
오라클 DBMS를 사용하는 곳은 주로 Read Committed수준을 사용하며, Mysql을 사용하는 곳은 Repeatable Read를 주로 사용한다.

> 테스트를 하려면 Autocommit이 off인 상태에서 해야한다.


 
### Read Uncommitted
아직 커밋되지 않는 것들을 다른 트랜잭션에서 읽을 수 있다.  따라서 Commit전에 롤백이 된 경우에도 이미 읽어버렸다면 정상적으로 처리하기 때문에 Dirty Read가 발생한다. 
이로 인해 Mysql을 사용한다면 적어도 Read Committed를 사용해야 한다. Read Uncommitted는 최소한의 격리수준으로 인정하지 않을 정도로 정합성 문제가 많다. 


### Read Committed
커밋된 것만 읽어오는 격리수준을 말한다. 
A트랜잭션에서 데이터를 변경하고 커밋을 하지 않았을때 B트랜잭션에서 이를 읽어올 경우 아직 커밋이 안되어있으므로 변경한 값을 읽어오지 못하고 언두로그에 있는 변경 전 값을 읽어온다. 

하지만 이러한 격리수준으로 인해 Non-Repeatable Read가 발생한다.
하나의 트랜잭션에서는 언제나 같은 결과를 반환해야 한다. 하지만 B트랜잭션이 종료되지 않고 A트랜잭션에서 커밋 전과 후에 각각 읽어왔다면 조회해온 2개의 데이터가 다를 것이다. 즉 정합성이 깨지는 문제가 발생할 수 있다. 

[주의사항] <br>
트랜잭션 내에서 Select하는 것과 트랜잭션 밖에서 Select하는 것의 차이는 Repeatable Read격리수준에서 발생한다. 그전에는 별 차이가 없다.
Repeatable Read에서는 정합성을 보장하기 때문.

### Repeatable Read
바이너리 로그를 설정했다면 최소 Repeatable Read를 사용하는 것이 좋다. 
InnoDB 스토리지 엔진은 롤백을 대비하기 위해서 언두영역에 백업해두고 실제 레코드 값을 변경한다.(MVCC)
따라서 이를 사용하여 동일 트랜잭션 내에서는 같은 결과를 낼 수 있도록 해준다. 물론 Read Committed도 MVCC개념을 사용하지만 백업된 레코드의 여러 버전가운데 몇번째꺼를 읽어오느냐의 차이에 있다.

InnoDB의 트랜잭션은 모두 고유의 순증 번호를 가지고있으며, 언두로그나 레코드에는 트랜잭션 번호가 숨겨져 있다. 따라서 각각의 트랜잭션은 본인이 속한 트랜잭션 번호보다 낮을 값의 트랜잭션이 변경한 값들을 읽어온다. 

따라서 Begin트랜잭션을 하고 오래 두면 언두 영역이 백업된 데이터로 무한정 커질 수 있고 이는 성능부하로 이어지게 되니 트랜잭션을 짧게 가져가는게 좋다. 

하지만 Repeatable Read에도 부정합이 발생할 수 있다. 
테이블에 변경이 아닌 Insert를 할 경우 언두 로그에 락을 걸 수도 없으니 조회결과가 달라질 수 있다. (Phantom Read)
예를들어 A트랜잭션에서 Insert한 것을 B트랜잭션이 A가 insert하기 전 후에 읽어오면 결과가 달라질 수 있다.


### Serializable 
Phantom Read도 발생하지 않는다. 
아주 강력한 격리레벨이며, Innodb에서는 갭 락, 넥스트 키 락 덕분에 Repeatable Read 격리수준에서도 Phantom Read가 발생하지 않는다.

