---
title: RealMySql 8.0 - 아키텍처(Mysql 엔진) 
date: 2023-08-09
categories: [도서, RealMySql]
tags: [mysql, RealMySql, 아키텍처]
math: true
mermaid: true
---

## Mysql Architecture
![Image](https://github.com/phantom08266/TIL/assets/39672033/e1b73437-55e2-4a31-9a40-a3beaf7828e5)

Mysql 엔진 : SQL 인터페이스, SQL 파서, 옵티마이저 등의 기능을 제공하며, 커넥션 핸들러도 관리한다.(DBMS의 두뇌역할) <br>
스토리지 엔진 : 디스크에서 데이터를 읽고 쓰는 역할을 담당한다. (DBMS의 손과 발을 담당) <br>
핸들러 API : Mysql 엔진이 스토리지 엔진에게 데이터를 읽어오거나 저장하도록 요청할 수 있는 요청 API들을 관리한다. <br>
```shell
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

<br>

## Mysql 스레딩 구조
Mysql은 스레드 기반으로 동작한다. <br>
포그라운드, 백그라운드 스레드로 구분한다. <br>
```shell
mysql> SELECT thread_id, name, type, processlist_user, processlist_host, FROM performance_schema.threads ORDER BY type, thread_id;
```

one_connection이란 스레드가실제 사용자의 요청을 처리하는 포그라운드 스레드이다. <br>

### 포그라운드 스레드

보통 사용자의 접속 수 만큼 포그라운드 스레드가 생성된다. <br>
사용자 요청이 들어오면 Mysql 서버는 포그라운드 스레드를 생성하고 이를 할당하여 사용자의 요청을 처리한다. <br>
요청이 완료되면 스레드는 종료하거나 스레드 캐시에 반환한다. (스레드 풀이랑 비슷한 개념같음) <br>
스레드 캐시는 일정 갯수 이상의 스레드만 존재하도록 유지하고 이를 thread_cache_size로 설정할 수 있다. <br>

### 백그라운드 스레드
백그라운드 스레드의 역할은 아래와 같다. <br>

1. Insert Buffer를 병합
2. 로그를 디스크로 저장
3. InnoDB버퍼 풀의 데이터를 디스크에 저장
4. 데이터를 버퍼로 읽어옴
5. 잠금이나 데드락을 모니터링

각각의 쓰기와 읽기 스레드 설정은 innodb_write_to_threads, innodb_read_io_threads로 설정할 수 있다. <br>
InnoDB에서는 데이터를 읽는 작업이 포그라운드 스레드가 처리하기 때문에 읽기 스레드는 많이 설정할 필요가 없으며, 쓰기 스레드는 넉넉하게 설정하는것이 좋다. <br>
MyISAM은 쓰기 작업에 버퍼링 기능이 없지만 InnoDB는 버퍼링 기능이 있어 데이터를 완전히 디스크로 저장할때까지 기다리지 않아도 된다. <br>

<br>

## 메모리 할당 및 사용구조

### 글로벌 메모리 영역 vs 로컬 메모리 영역

**[글로벌 메모리]** <br>
Mysql 서버가 실행되면서 운영체제로 부터 할당되고, 시스템 변수로 설정해둔 만큼 운영체제로부터 할당 받는다고 생각하는게 쉽다. <br>

포그라운드 스레드 수와 무관하며, 주로 하나의 메모리 공간에만 할당된다. <br>
여러개의 메모리 공간에 할당이 되어도 모든 스레드에 의해 공유 가능하다. <br>

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

<br>

**[로컬 메모리]** <br>
클라이언트와 Mysql 서버와의 커넥션을 세션이라 불리며, 이 세션을 처리하기 위해 할당한 메모리 영역을 로컬 메모리 영역이라 한다. <br>
각 포그라운드 스레드 별로 스레드가 독립적으로 할당되며, 해당 메모리는 절대 공유하지 않는다. <br>

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼


<br>

## 플러그인 스토리지 엔지 모델

Mysql은 플러그인 모델이다. <br>
즉 다양한 기능들을 플러그인으로 제공하고, 필요한 기능들만 설치해서 사용할 수 있다. <br>
심지어 스토리지 엔진까지 플러그인처럼 선택하고 사용할 수 있다. <br>

이 책을 읽고 '하나의 쿼리작업을 수행하기 위해서 Mysql 엔진 영역에서 동작하는지, 스토리지 엔진에서 동작하는지' 구분할 수 있어야 한다. <br>

```shell
# mysqld 서버가 지원해주는 스토리지 엔진은 아래 명령어로 확인 가능하다.
mysql> SHOW ENGINES;

# 플러그인 확인
mysql> SHOW PLUGINS;
```

Mysql 플러그인 API가 매뉴얼에 있으므로 원하는 기능들을 만들어볼 수도 있다. <br>

<br>

## 컴포넌트
Mysql 8.0부터 지원되며 플러그인의 단점을 보완하기 위해 나온 개념이다. <br>

플러그인 단점
1. 플러그인끼리 통신이 불가능함
2. Mysql서버변수, 함수를 직접 호출하여 캡슐화 안됨
3. 플러그인끼리 상호 의존관계를 설정하기 어려움

<br>

## 쿼리 실행구조

- **쿼리파서** : 기본 문법 오류를 찾고 사용자에게 알림
- **전처리기** : 실제 존재하지 않는 테이블, 필드 이거나 권한상 사용할 수 없는 개체의 토근을 거른다. 
- **옵티마이저** : 쿼리를 가장 저렴한 비용으로 실행할 수 있는 방법을 찾는다. 
- **실행엔진** : 실행 엔진은 옵티마이저가 만들어준 계획대로 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결한다.
- **핸틀러(스토리지 엔진)** : 핸들러 == 스토리지 엔진, 디스크로 저장하고 읽어오는 역할을 담당한다.


### 쿼리 캐시
동일한 쿼리가 요청이 들어오면 쿼리를 실행하지 않고 이전에 실행했던 결과물을 그대로 반환하여 성능향상을 꾀했다. <br>
하지만 테이블 데이터가 변경되면 기존의 저장된 캐시들을 다 삭제해야해서 이로인한 성능부하가 발생하였고 원인모를 버그가 발생하였다. <br>
따라서 mysql8.0부터는 쿼리 캐시개념을 제거하였고 시스템변수도 제거하였다. <br>


### 스레드 풀
커뮤니티 버전에서는 지원하지 않고 엔터프라이즈 버전에서만 지원한다. <br>
하지만 Percona Server플러그인을 Mysql서버 버전과 일치하는 버전의 플러그인을 설치하면 스레드풀을 사용할 수 있다. <br>
스레드 풀을 사용하는 이유는 스레드 갯수를 CPU가 제한된 개수의 스레드만 처리할 수 있게 해서 서버의 자원소모를 줄이는 것이다. <br>


