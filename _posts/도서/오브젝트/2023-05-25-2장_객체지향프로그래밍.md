---
title: 오브젝트 - 2장 객체지향 프로그래밍
date: 2023-05-25
categories: [도서, 오브젝트]
tags: [OOP, 오브젝트]
math: true
mermaid: true
---

## 2장의 주요 포인트

### 객체지향 프로그래밍이 강력한 이유

- **요구사항**과 **프로그램**을 **객체라는 동일한 관점**에서 바라볼 수 있다.
- 따라서 객체지향임으로 클래스 대신 객체관점으로 고민을 해야하며, 윤곽이 잡히면 타입 기반 클래스를 고려하는 방식으로 접근해야 한다.

<br>

### 캡슐화, 다형성

<aside>
✅ 캡슐화 : 데이터와 기능을 객체 내부로 묶는 것을 말한다.
</aside>

주로 접근 제한자를 사용하여 외부 접근을 통제할 수 있다.
또한 클래스에서 이러한 **접근 제한자를 제공하는 이유**는 **객체의 자율성을 보장**하기 위함이다.
객체 스스로 상태관리를 하거나, 판단, 행동을 하게 하기 때문이다.

<br>

<aside>
✅ 다형성 : 동일한 메시지를 수신하지만 객체 타입에 따라 각기 다르게 동작한다.

</aside>

다형성은 컴파일 시간 과 실행시간 의존성이 다를 수 있다는  사실을 알고 있어야 한다.

다형성을 사용한다는 건 실행시간에 의존성이 주입된다는 것 이며, 이는 코드를 이해하기 어려워질 수 있다. 대신 유연함을 얻을 수 있다.

> 동적 바인딩, 지연 바인딩 : 메서드, 메시지가 실행시점에 바인딩 <br>
> 초기 바인딩, 정적 바인딩 : 메서드, 메시지가 컴파일시점에 바잉딩

<br>

### 상속 vs 합성

<aside>
✅ 상속 : 부모클래스의 기능을 그대로 이어받아 자식 클래스에서 재사용하기 위함.

</aside>

코드 재사용하기 위해 주로 사용하지만 객체지향 설계 관점에서 보면 약간의 문제가 있다.

1. 캡슐화가 깨진다.
   - 부모클래스의 내용을 자식클래스가 알아야 하기 때문에 객체 자율성이 깨지게 된다.
      - 부모클래스에서 템플릿 메서드 패턴을 사용하여 자식의 추상메서드를 호출한다면 더욱더 자식클래스는 부모 클래스의 기능들을 알고 있어야 한다.

   >    템플릿 메서드 패턴 : 부모 클래스에 기본적인 알고리즘을 작성 후 중간에 필요한 처리를 자식클래스에게 위임하는 디자인 패턴

2. 설계가 유연하지 않을 수 있다.
   1. 하나의 기능을  수정하기 위해서 연관된 부모 클래스들을 수정해야 할 수 있다.
   2. 컴파일 타임에 하나의 단위로 강하게 결합된다.

<br>

<aside>
✅ 합성 : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

</aside>

위 상속의 문제점들을 모두 해결한다.

1. 캡슐화 부분은 인터페이스에 정의된 메시지를 통해서만 재사용이 가능함으로 자연적으로 캡슐화할 수 있다.
2. 인터페이스를 통해 약결합이 되기 때문에 설계가 유연해지며, 클래스보다 인터페이스를 교체하는 것이 비교적 쉽다.

<br>


### 객체지향 설계의 핵심


✅ 객체지향 설계의 핵심은 적절한 **협력을 식별**하고 **협력에 필요한 역할을 정의**한 후 역할을 수행할 수 있는 적절한 객체에게 적절한 **책임을 할당**하는 것.

- 협력 식별 = 추상화할 부분 찾기(할인정책 DiscountPolicy)
  - 추상화 특징 : 세부사항에 억눌리지 않고 상위 개념만으로도 도메인의 중요한 개념을 설명할 수 있다.
- 협력에 필요한 역할 정의 = 추상화한 부분끼리 연결하여 협력의 흐름을 만든다.(Movie → DiscountPolicy → DiscountCondition)
- 객체에게 적절한 책임을 할당 (DiscountPolicy를 구현하는 AmountDiscountPolicy, PercentDiscountPolicy)

