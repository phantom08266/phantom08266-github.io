---
title: 오브젝트 - 13장 서브클래싱과 서브타이핑
date: 2023-07-02
categories: [도서, 오브젝트]
tags: [OOP, 오브젝트]
math: true
mermaid: true
---

## 13장 핵심 포인트
상속을 올바르게 사용하려면 타입 계층에 대해서 잘 이해해야 한다. <br>
이번 장에서는 올바른 타입 계층을 구성하는 원칙에 대해서 알아본다. <br>

<br>

## 타입 계층
부모 클래스는 일반적인 개념을 구현하고, 자식 클래스는 특수한 개념을 구현해야 한다. <br>
따라서 부모 클래스는 일반화(Generalization)이라 불리며, 자식 클래스는 특수화(Specialization)이라 불린다. <br>

타입 계층으로 구성해야하는 이유는 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체를 행동 기반으로 구성해야 한다. <br>


> 📘 **[참고]** 객체지향 프로그래밍 vs 객체기반 프로그래밍 <br>
> 객체기반 프로그래밍은 상속, 다형성을 지원하지 않는다.(대표적으로 비주얼 베이직언어가 있다.)  
> 객체지향 프로그래밍은 상속, 다형성을 지원한다. (대표적으로 자바, C++ 등이 있다.)

객체지향 패러다임 관점에서는 객체의 타입을 **객체들이 수신할 수 있는 메시지 종류를 정의하는 것**으로 정의했다. <br>
이는 앞서 배운 **퍼블릭 인터페이스**를 통해서 객체들을 타입으로 구분지을 수 있다는 말이다. <br>

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.

이를 통해 알 수 있듯이 객체에게 중요한건 속성이 아니라 행동이라는 것을 알 수 있다. <br>

<br>

## 서브클래싱과 서브타이핑

상속을 그럼 언제 사용해야 하는걸까? <br>
- 상속관계가 is-a관계가 성립되는가
- 클라이언트 관점에서 부모 클래스의 타입으로 자식 클래스르 사용해도 클라이언트가 문제없는가(행동 호환성)

### is-a 관계
"자식 클래스는 부모 클래스다" 라는 말이 성립된다면 사용 가능하다. <br>
단 **is-a관계가 성립이 되더라도 두번째인 행동 호환성이 성립되지 않는다면 상속을 사용해서는 안된다.** <br>
예를들어 팽귄은 새이다. 라는 is-a관계가 성립되지만, 새가 날 수 있는 행동을 팽귄이 할 수 없기 때문에 상속을 사용해서는 안된다. <br>

### 행동 호환성
클라이언트 관점으로 행동이 호환될 경우에만 타입 계층으로 묶어서 사용할 수 있다. <br>
따라서 앞서 예를들었던 새와 팽귄의 관계를 다시 생각해보면, 새는 날수도 있지만 걸을 수도 있다. <br>
이를 이용해서 인터페이스를 분리하여 설계를 하게되면 아래와 같이 설계할 수 있다. <br>

![image](https://github.com/phantom08266/TIL/assets/39672033/a6f2804e-3b82-43a8-b564-ea0e47a6f677)

즉 클라이언트가 기대하는 바에 따라 분리되어야 한다. <br>
이렇게 인터페이스를 분리하는 것이 SOLID원칙 중 하나인 인터페이스 분리원칙이다. ISP(Interface Segregation Principle)

이처럼 인터페이스를 분리하면 비대해지는 클래스를 기능분리 하여 결합도를 낮출 수 있으며, 의존성또한 낮아지게 된다. <br>
또한 클라이언트가 기대하는 행동에 집중할 수 있다. <br>


### 서브클래싱(Subclassing) vs 서브타이핑

**[서브클래싱]** <br>
다른 클래스의 코드를 **재사용**할 목적으로 상속을 사용하는 경우. <br>
자식 클래스와 부모 클래스의 **행동이 호환되지 않아** 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.<br>
구현상속, 클래스 상속이라고도 불린다.

**[서브타이핑]** <br>
**타입 계층**을 구성하기 위해 상속을 사용하는 경우 <br>
자식 클래스가 부모 클래스와의 **행동이 호환됨**으로 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. <br>
인터페이스 상속이라고도 불린다. 

이 둘을 구분하는 기준은 상속을 사용하는 목적이 어떤것이냐에 따라 결정된다. <br>
이 둘의 개념을 좀 더 자세히 알아보기 위해 SOLID원칙 중 하나인 리스코프 치환 원칙(LSP - Liskov Substitution Principle)을 알아봐야 한다. <br>

**[리스코프 치환 원칙]** <br>
서브타입은 기반 타입에 대해 대체 가능해야 한다. <br>
즉 이를 사용하는 클라이언트가 기반 클래스를 통해 서브 클래스를 사용하는데 문제가 없어야 한다. <br>
이는 서브타이핑 개념과 유사하다. <br>


## 유연한 설계를 위한 OCP, DIP, LSP
앞서 배운 개념들을 조합하면 유연한 설계를 할 수 있다. <br>
클라이언트들이 추상 클래스에만 의존하도록 설계한뒤(DIP), 리스코프 치환 원칙(LSP)을 잘 지켰다면 추상 클래스를 구현한 서브 클래스들은 
행동이 호환되기 때문에 자식 클래스를 추가하거나 변경하여도 클라이언트에 영향을 주지 않는다. <br>
마지막으로 LSP 원칙을 잘 지키면 자동으로 개방 폐쇄 원칙(OCP)이 만족된다. <br>

<br>

## 클라이언트 관점에서의 자식클래스가 부모 클래스를 대체한다?
클라이언트 관점에서 자식 클래스가 부모 클래스를 대체한다는 것은 무슨 의미일까? <br>

> 서브 타입이 리스코프 치환 원칙을 맞족시키기 위해서는 클라이언트와 슈퍼타입 간의 체결된 계약을 준수해야 한다.

- 서브타입에 더 강력한 사전 조건을 정의할 수 없다. 
- 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
- 사후타입에 더 강력한 사전 조건을 정의할 수 있다.
- 서후타입에 더 약한 사후조건을 정의할 수 없다. 

위 4가지 조건을 만족시키는 클래스간의 **계약**에 의한 서브타이핑을 만족시키면 충분히 클라이언트 관점에서 바라볼때 자식 클래스가 부모 클래스를 대체할 수 있다고 볼 수 있다. <br> 



