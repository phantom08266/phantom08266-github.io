---
title: 오브젝트 - 12장 다형성 
date: 2023-06-27
categories: [도서, 오브젝트]
tags: [OOP, 오브젝트]
math: true
mermaid: true
---

## 12장 핵심 포인트


## 다형성
상속은 재사용을 목적으로 사용하면 안되는 것을 앞서 배웠다. <br>
대신 상속을 사용하는 목적이 타입 계층을 구조화 하여 다형성을 사용하는 것은 좋은 방법이다. <br>

> 다형성 : 런타임에 객체가 주입되어 동작하는 방식을 결정하는 것

다형성이란 그리스어에서 '많은'을 의미하는 poly와 형태를 의미하는 morph의 합성어로 '많은 형태를 가질 수 있는 능력'을 의미한다. <br>
다형성도 여러가지가 있지만 앞으로 알아볼 다형성은 포함 다형성으로 메시지가 동일해도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 것을 말한다. <br>

<br>

## 상속을 이용한 다형성
어떻게 보면 상속을 **데이터 관점의 상속**과 **행동 관점의 상속**으로 나누어 생각해 볼 수 있다. <br>

> 데이터 관점의 상속 : 부모 클래스에서 선언한 인스턴스를 자식 클래스에서 사용할 수 있다.

> 행동 관점의 상속 : 부모 클래스에 선언한 메서드를 자식 클래스에서 사용할 수 있다. 

하지만 이렇게 나눠서 생각하여 자칫 잘못하면 상속을 사용하는 이유는 재사용 때문이라고 생각할 수 있다. <br>
상속의 목적은 다형성을 가능하게 하는 타입계층을 구축하기 위한 것 <br>
다형성이란 개념을 이해하기 위해서는 사전에 메서드 오버라이딩, 메서드 오버로딩 개념을 알고 있어야 한다. <br>

> 메서드 오버라이딩 : 부모 클래스에서 정의한 메서드 시그니처를 자식클래스에서 동일한 시그니처로 재정의 하는 것

> 메서드 오버로딩 : 부모 클래스에서 정의한 메서드 이름은 동일하지만 자식클래스에서 메서드 시그니처가 다른 메서드를 정의하는 것

<br>

### 객체지향 프로그래밍에서는 어떻게 다형성을 지원할까? 
**업캐스팅**과 **동적 바인딩**을 통해 다형성을 지원한다. <br>

> 업캐스팅 : 부모 타입으로 선언된 변수에 자식 타입의 인스턴스를 할당하는 것 

> 동적 바인딩 : 런타임에 메시지를 수신한 객체의 타입을 확인하여 그에 맞는 메서드를 실행하는 것

따라서 업캐스팅과 동적 바인딩을 통해 SOLID원칙 중 하나인 **개방폐쇄 원칙**을 지킬 수 있게 되면서 유연한 설계가 가능하게 된다. <br>

<br>

### 동적 메서드 탐색과 다형성
그렇다면 컴파일러는 어떻게 동적 바인딩을 구현할까? <br>
![image](https://github.com/woowa-backend/object/assets/39672033/df87e30d-1f2c-45c9-bb00-73abce745731)

**[동작순서]**
1. self라는 임시 참조변수 생성하여 메시지를 수신 객체를 가리킨다.
2. self에 저장된 객체의 클래스에서 메서드 탐색(Men 클래스의 메서드 탐색)
3. 없으면 클래스(Men)가 가지고 있는 parent 포인터변수를 사용하여 부모 클래스 접근하여 메서드 탐색 (People 클래스의 메서드 탐색)
4. 없으면 클래스(People)가 가지고 있는 parent 포인터변수를 사용하여 부모 클래스 접근하여 메서드 탐색 (Object 클래스의 메서드 탐색)
5. 탐색이 완료되면 임시 self 참조변수 제거

따라서 위 순서대로 **상속 계층에 따라 메서드 탐색을 위임**하며, self 참조변수를 이용하여 런타임 시점에 **동적으로 문맥이 결정**된다. <br>

> 단 주의사항으로 이런 메서드 탐색을 위임하는 방식은 언어마다 다를 수 있다.

즉 언어마다 메서드 오버라이딩과 오버로딩 동작방식이 조금 다를 수 있다. <br>
자바에서는 메시지 위임과 관련해서 별도의 코드를 작성할 필요없이 컴파일러가 알아서 self 임시 참조변수와 parent 포인터 변수를 사용하여 타입에 맞는 메서드를 호출해주지만, <br>
C++에서는 부모 클래스에서 정의한 메서드 이름과 동일하게 자식클래스에서 오버로딩 하면 그 이름을 가진 모든 부모클래스의 메서드들이 감춰진다. <br>
따라서 Java에서는 동작하던 코드가 C++에서는 동작하지 않을 수 있다. <br>


## Self 참조와 super 참조

### self 참조
> self참조는 메시지를 수신하는 객체의 클래스에 따라 동적으로 탐색위치를 결정한다.


~~~java
public class Lecture {
  public String stats() {
    return String.format("%s", getEvaluationMethod());
  }

  public String getEvaluationMethod() {
    return "Pass or Fail";
  }
}

public class GradeLecture extends Lecture {
  @Override
  public String getEvaluationMethod() {
    return "Grade";
  }
}
~~~

![image](https://github.com/woowa-backend/object/assets/39672033/9eb590a1-a6b1-48c0-b87c-0680e8924817)

GradeLecture 인스턴스를 통해 stats()메서드 호출순서를 보면 아래와 같다. <br>
1. stats() 메서드를 호출하면 self 참조변수에 GradeLecture 인스턴스가 저장된다.
2. GradeLecture 클래스에는 stats()가 없어 부모클래스인 Lecture 클래스로 탐색을 위임한다.
3. 부모 클래스인 Lecture 클래스에 stats()메서드를 실행시킨다.
4. getEvaluationMethod() 메서드를 호출하기 위해 self 참조변수에 저장된 GradeLecture인스턴스의 GradeLecture 클래스부터 탐색을 시작한다. 


### Super

> super참조는 메시지를 전송하는 클래스의 부모 클래스부터 탐색을 시작한다.

super의 용도는 부모클래스에 정의된 메서드를 실행하기 위한 것이 아니라, 지금 이 클래스의 부모클래스부터 메서드 탐색을 시작하라고 컴파일러에게 알려주는 역할을 한다. <br>
물론 언어에 따라서 컴파일 시점에 알려주는 언어도 있고 런타임에 동적으로 알려주는 스칼라같은 언어도 있다. <br>


