---
title: 오브젝트 - 15장 디자인 패턴과 프레임워크
date: 2023-07-12
categories: [도서, 오브젝트]
tags: [OOP, 오브젝트]
math: true
mermaid: true
---


## 15장 핵심 포인트
디자인 패턴과 프레임워크의 특징과 이를통해 해결하려는 문제가 무엇인지 알아본다. <br>
또한 이들이 중요하게 생각하는 것이 무엇인지 알아보고, 이를통해 어떠한 문제를 해결하려고 하는지 알아본다. <br>

<br>

## 디자인 패턴과 설계 재사용

> 디자인 패턴 : 객체들간의 협력을 일관성 있게 만들기 위해 설계를 재사용하기 위한 설계들의 묶음.

패턴을 알아두면 개발자간의 대화를 할때 장황한 대화를 단순한 대화로 바꿀 수 있다. <br>
또한 패턴은 아키텍처 패턴, 분석패턴, 디자인 패턴, 이디엄 이렇게 4가지로 나뉜다. <br>
이디엄은 특정 언어에 종속되는 패턴임으로 가볍게 넘어가고 분석패턴은 도메인의 내의 개념적인 문제를 해결하는데 초점을 맞춘 패턴이다. <br>
아키텍처 패턴은 시스템의 전체적인 구조를 설계하는데 초점을 맞춘 패턴이다. <br>

**[캡슐화를 이용한 디자인패턴]**

1. Strategy 패턴
   - 알고리즘의 변경을 캡슐화하여 이를 구현하기 위해 객체 합성을 사용한다.
   - 객체간의 결합도를 낮추고, 런타임에 알고리즘을 변경할 수 있게 된다. 
2. Template Method 패턴
   - Strategy 패턴과 유사하지만 합성대신 상속을 사용한 패턴이라 볼 수 있다.
   - 주로 Client들은 부모 클래스에서 제공하는 메서드를 호출하고, 이를 구현하는 서브 클래스들은 client에 제공하는 Public메서드 안에서 호출되는 특정 메서드를 오버라이딩 하여 변경되는 부분을 구현한다.
   - Strategy 패턴처럼 런타임에 객체를 변경할 수는 없지만, 이런 교체문제만 없다면 strategy 패턴보다 더 복잡도가 낮을 수도 있다.
3. Decorator 패턴
   - 주어진 상황 및 용도에 따라 어떤 객체에 책임(기능)을 동적으로 추가하는 패턴이다.
   ![image](https://github.com/whatsthelunchmenu/ClimbLabs-api/assets/39672033/36c9dd9c-1638-4c5f-8689-432bdcde8674)
   - Component : 클라이언트에서 사용하는 기본 기능이며, ConcreteComponent와 Decorator의 공통기능 정의
   - ConcreteComponent : Component의 실질적인 기능을 구현한 클래스
   - Decorator : Component에서 제공하는 **기본기능에 추가하여** 더 많은 기능을 제공하기 위해 ConcreteComponent와 ConcreteDecorator들을 동일시 해주는 역할
   - ConcreteDecorator : 추가적인 기능을 제공하기 위해 구현한 구현체

4. Composite 패턴
   - 복합객체를 단일 객체와 동일 취급을 해주는 패턴이다.

패턴은 복잡성의 가치가 단순성을 넘어섰을때 사용해야 한다. <br>
따라서 무분별한 패턴 사용은 오히려 복잡성을 높일 수 있기 때문에 설계를 좀 더 단순화할 수는 없는지를 먼저 고민하고, 패턴을 사용하더라도 트레이드오프를 통해 적절한 패턴을 적용하는 것이 중요하다. <br>

<br>

## 프레임워크와 코드 재사용 

> 프레임워크 : 객체들간의 협력을 일관성 있게 제공하기 위해 설계와 코드를 함께 재사용할 수 있도록 반복적인 부분들을 미리 구현해놓은 것.

### 프레임워크가 나오게된 이유
재사용 관점으로 생각해보면 설계 재사용보다는 코드 재사용성을 높인다면 빠르게 구현을 할 수 있을 것이다. <br>
따라서 코드 재사용성을 높이기 위해 컴포넌트 기반의 재사용성이란 개념이 나왔다. <br>

하지만 여러곳에서 동일하게 사용하는걸 컴포넌트화 하면 좋겠지만 현실세계의 복잡한 문제들을 해결하기 위해서는 재사용 가능한 컴포넌트들을 만드는 것이 사실상 불가능했다. <br>

그래서 설계를 재사용하면서도 유사한 코드를 반복적으로 구현하는 문제를 피하게 하기위해 나온 것이 **프레임워크**이다. <br>

<br>

### 프레임워크의 특징과 예시
프레임워크는 재사용성을 향상시키기 위해 상속, 합성 개념을 이용하여 일관성 있는 협력을 제공한다. <br>
또한 상위정책과 하위정책 모두 추상화에 의존하게 만들어서 의존성 역전 원칙을 만족시킨다. <br>
그러기 위해서 변하는 것과 변하지 않는 것을 구분하고 코드 뿐만아니라 패키지를 분리하여 배포단위를 만들어야 한다. <br>

지금까지 나온 개념을 예를들어 설명하면 다음과 같다. <br>

스프링 프레임워크에서는 대표적으로 Slf4j를 사용하여 로깅을 사용할 수 있다. <br>
Slf4j의 추상 인터페이스를 구현하는 각각의 로깅 라이브러리들(logback, log4j 등)을 원하는 의존성 주입만으로 사용할 수 있다. <br> 
이렇게 변하는 부분을 분리하여 배포단위를 만들어 갈 수 있다. <br>

또한 스프링 프레임워크는 **의존성 역전 원칙(DIP)** 을 기반으로 객체들을 생성자주입을 권장하며, 이를 프레임워크가 대신 판단하고 빈을 주입해주는 **제어의 역전 원리(IOC)** 개념을 제공한다. 

이러한 프레임워크가 제공해주는 부분들로 인해 반복적인 코드대신 생산성 있는 코드들로만 빠르게 구현할 수 있게 되었다. <br> 


결론은 디자인 패턴, 프레임워크 모두 협력을 일관성 있게 제공하기 위함이다. <br>
