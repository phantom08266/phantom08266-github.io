---
title: 오브젝트 - 부록A(계약에 의한 설계)
date: 2023-07-13
categories: [도서, 오브젝트]
tags: [OOP, 오브젝트]
math: true
mermaid: true
---

## 부록A 핵심 포인트


## 협력과 계약

인터페이스 만으로는 객체의 행동에 대해 자세한 세부사항을 알 수 없다. <br>
시그니처만으로는 클라이언트와 서버가 협력을 위해 수행해야 하는 제약조건을 명확하게 정의할 수 없다. <br>

이를 위해서 C#에서는 Code Contract 같은 도구들을 사용해서 부족한 계약에 관련된 부수효과, 문서화 등을 지원하였지만 
지금은 .NET 프레임워크에서는 공식적으로 제공하지 않는다고 한다.. <br>

이러한 Code Contract 들을 사용하면 뭐가 좋을까? <br>

1. 메서드 시그니처 이외의 사전조건, 사후조건, 불변식 즉 계약규칙을 표현할 수 있다.
2. 가변성 규칙을 통해 교체 가능한 타입에 대해서 정의할 수 있다.

<br>

### 계약규칙

#### **[서브타입에 더 강력한 사전조건을 정의할 수 없다]**
사전 조건은 파라미터의 조건이라 보면되고 사후조건은 반환타입에 대한 조건이라고 생각하면 쉽다. <br>
일단 슈퍼타입을 보고 클라이언트들은 계약을 했는데 서브타입에서 이를 반하는 행위를 한다는 것은 계약을 위반하는 것과 다름없다. <br>
물론 더 강력하게 제약을 거는 것이 해당 서브타입 관점으로만 보면 맞는 것 같지만 이를 사용하는 클라이언트 관점에서 보면 납득할 수 없는 계약 위반이기 때문이다. <br>
즉 리스코프 치환원칙을 위반하게 된다. <br>

#### **[서브타입에 더 완화된 사후조건을 정의할 수 없다]**
위에서 설명한 클라이언트가 계약한 내용 관점으로 생각한다면 당연한 이야기이다. <br>
사후조건을 완화시킨다는 말은 서버가 클라이언트에게 제공하겠다고 보장한 계약을 충족시키지 못하는 것을 의미하기 때문이다. <br>

#### **[슈퍼타입의 불변식은 서브타입에서도 반드시 유지돼야 한다]**
객체가 생성된 직후부터 소멸될때까지 불변식을 만족시켜야 한다. <br> 

<br>

### 가변성 규칙

#### **[서브타입은 슈퍼타입이 발생시키는 예외와 다른 타입의 예외를 발생시켜서는 안 된다]**

#### **[서브타입의 리턴 타입은 공변성을 가져야 한다]**
우선 공변성, 반공변성, 무공변성 어휘에 대해서 이해할 필요가 있다. <br>
**공변성** : 서브타입이 슈퍼타입 대신 사용될 수 있는 것을 말한다. 즉 리턴타입이 서브타입이고 이를 수신하는 타입이 슈퍼타입이어도 문제가 없다는 것을 뜻한다. <br>
**반공변성** : 공변성과 반대로 슈퍼타입이 서브타입 대신 사용될 수 있는 것을 말한다. <br>
**무공변성** : 아무런 관련이 없는 것을 말하며, 공변성, 반공변성을 지원하지 않는 것을 말한다. <br>

슈퍼타입 대신 서브타입을 반환하는 것은 더 강력한 사후조건을 정의하는 것과 같은 의미이다. <br>

> 공변성과 반공변성은 어떤 언어를 사용하느냐에 따라 다를 수 있다. <br>
> 자바에서는 리턴타입 공변성을 지원하지만 C# 에서는 리턴타입에 대해 무공변성이다. <br>

대부분의 객체지향 언어는 반공변성을 지원하지 않기 때문에 파라미터 반공변성에 대해서만 알아보자. <br>

**파라미터 반공변성이란** : 부모클래스에서 구현된 메서드를 자식 클래스에서 오버라이딩할 때 파라미터 타입을 부모 클래스에서 사용한 파라미터의 슈퍼타입으로 지정할 수 있는 것을 말한다. <br>

<br>

### 정리
리스코프 치환원칙을 따른다는 것은 서브타입이 슈퍼타입으로 언제든 대체될 수 있다는 의미라는 것을 알았다. <br>
이는 결국 계약규칙과 가변성 규칙을 준수한다는 것을 의미한다. <br>
또한 서브타이핑 관계를 잘 만들고 싶다면 
1. 서브타입에 더 강력한 사전조건이나 더 완화된 사후조건을 정의해서는 안된다.
2. 슈퍼타입의 불변식을 유지하기 위해 노력해야 한다.



